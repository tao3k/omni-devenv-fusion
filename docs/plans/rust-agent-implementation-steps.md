# Rust Agent: Implementation Steps (for Audit)

> Ordered list of the next implementation steps for the **Rust agent**. Once approved, we start from Step 1. The agent talks to the **current MCP server (Python)**; no Rust MCP server in this phase.

**Prerequisites (done)**: Phase A (omni-mcp-client), Phase B (omni-agent one-turn loop, session, LLM client).

**MCP config**: Load MCP server list **only from config** — **mcp.json** (same format as Cursor / Claude Desktop and our Python side). No env fallback. Default path: `.mcp.json` in project root; override with `--mcp-config <path>`. See Step 3 for the format.

**Reference discipline**: When implementing steps that parallel [Nanobot](https://github.com/HKUDS/nanobot) or [ZeroClaw](https://github.com/zeroclaw-labs/zeroclaw), **review their source code** and update [reference-nanobot-zeroclaw-review.md](./reference-nanobot-zeroclaw-review.md): adopt their strengths and **explicitly avoid their pitfalls** so our implementation stays robust and high-quality.

---

## Step 1 — HTTP gateway

| Field           | Content                                                                                                                                                                                                                                                                                                                                                                                                                         |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **What**        | Add an HTTP server to the Rust agent so it can be used as a gateway.                                                                                                                                                                                                                                                                                                                                                            |
| **Concrete**    | Use axum (or existing choice): bind to a configurable host/port. **POST /message** with JSON body `{ "session_id": string, "message": string }`. For each request: load or create session by `session_id`, run `Agent::run_turn(session_id, message)`, return JSON `{ "output": string, "session_id": string }`. Use **omni-window** for session history (or keep current in-memory `SessionStore` and wire omni-window later). |
| **Config**      | Server listen address (e.g. `0.0.0.0:8080`). MCP server list: from **mcp.json** only (see Step 3).                                                                                                                                                                                                                                                                                                                              |
| **Deliverable** | `cargo run -p omni-agent` (or a `gateway` binary) starts HTTP server; `curl -X POST .../message -d '{"session_id":"s1","message":"hello"}'` returns agent reply.                                                                                                                                                                                                                                                                |
| **Deps**        | None (Phase B done).                                                                                                                                                                                                                                                                                                                                                                                                            |

---

## Step 2 — Stdio mode (optional gateway mode)

| Field           | Content                                                                                                                                                                                                                  |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **What**        | Support a stdio mode: read one line from stdin (user message), run agent turn, print reply to stdout.                                                                                                                    |
| **Concrete**    | Add a mode (e.g. `--stdio` or subcommand `omni-agent stdio`): loop read line → `run_turn(default_session_id, line)` → print `output`. Session ID from `--session-id` or default (e.g. `default`). Exit on EOF or Ctrl+C. |
| **Deliverable** | `echo "hello" \| cargo run -p omni-agent -- --stdio` (or similar) prints the agent’s reply.                                                                                                                              |
| **Deps**        | Step 1 optional (can be implemented in parallel with Step 1; same agent loop).                                                                                                                                           |

---

## Step 3 — MCP server config: mcp.json

| Field           | Content                                                                                                                                                                                                                                                                             |
| --------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **What**        | Use the **current universal MCP config** — **mcp.json** — to specify MCP server(s). Same format as Cursor, Claude Desktop, and our Python `get_mcp_config()`; one config for all clients.                                                                                           |
| **Concrete**    | **Path**: Load **only from config file**. Default `.mcp.json` in project root (or current dir); override with CLI `--mcp-config <path>`. No env fallback for MCP config or path. **Format**: `{ "mcpServers": { "<server_name>": { "type": "http", "url": "http://127.0.0.1:3002" } | { "type": "stdio", "command": "omni", "args": ["mcp", "--transport", "stdio"] }, ... } }`. Map to Rust `McpServerTransportConfig`: `type`"http" +`url`→`StreamableHttp { url }`(append`/sse`if our Python SSE expects it);`type`"stdio" +`command`/`args`→`Stdio { command, args }`. Per-server `env`, `timeout`, `idle_timeout`optional. Inference URL/model stay in agent config or env (e.g.`LITELLM_PROXY_URL`, `OMNI_AGENT_MODEL`). |
| **Deliverable** | With `.mcp.json` containing `mcpServers.omniAgent.url = "http://127.0.0.1:3002"`, the agent connects to that MCP server; or with `--mcp-config /path/to/mcp.json`.                                                                                                                  |
| **Deps**        | Step 1 (gateway loads this for MCP list).                                                                                                                                                                                                                                           |

---

## Step 4 — Multiple MCP servers

| Field           | Content                                                                                                                                                                                                                                                                                                                                                                                 |
| --------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **What**        | Config can list **multiple** MCP servers; agent connects to all, merges tools from each, and routes tools/call to the correct server by tool name or server id.                                                                                                                                                                                                                         |
| **Concrete**    | Extend `Agent::from_config`: connect to every entry in **mcp.json** `mcpServers` (Streamable HTTP or stdio per entry). On tools/list: aggregate tools from all servers (with optional server id in tool name or metadata to avoid clashes). On tools/call: determine which server owns the tool and call that server. Same behaviour as Cursor/Claude Code loading several MCP servers. |
| **Deliverable** | Config with two MCP servers; agent lists merged tools and a call to a tool on server A goes to A, on server B to B.                                                                                                                                                                                                                                                                     |
| **Deps**        | Step 3 (mcp.json already has multiple entries under `mcpServers`).                                                                                                                                                                                                                                                                                                                      |

---

## Step 5 — omni-memory in the agent loop (core)

| Field           | Content                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| --------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **What**        | Integrate **omni-memory** into the Rust agent loop: **two_phase_recall** (and optionally store_episode) so that memory is part of the agent’s behaviour. This is the **core** self-evolution feature.                                                                                                                                                                                                                                                                                                                  |
| **Concrete**    | Add dependency `omni-memory` to `omni-agent` (Rust API only, no pybindings). Create or load `EpisodeStore` (config: path, embedding_dim, table_name). In `run_turn`: (1) Before building the prompt, optionally call `two_phase_recall(session_id or last intent, k, k, lambda)` and inject recalled episodes into context or system message. (2) After a successful turn, optionally call `store_episode` (or equivalent) to persist the turn as an episode. Consolidation after N turns is an implementation detail. |
| **Deliverable** | Agent run with memory enabled: recall influences context and/or new turns are stored. Tests or manual run show recall/store behaviour.                                                                                                                                                                                                                                                                                                                                                                                 |
| **Deps**        | Step 1 (loop exists). omni-memory Rust API (EpisodeStore, two_phase_recall, store) is already available.                                                                                                                                                                                                                                                                                                                                                                                                               |

---

## Step 6 — CLI surface and documentation

| Field           | Content                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| --------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **What**        | Expose the Rust agent as a clear CLI and document how to run it with the current MCP server (Python).                                                                                                                                                                                                                                                                                                                                                                                                                 |
| **Concrete**    | (1) **CLI**: e.g. `omni agent --rust` or `omni-agent` with subcommands `gateway`, `stdio`; support `--mcp-config <path>`. (2) **Docs**: Short “Run the Rust agent” section: start the MCP server (e.g. `omni mcp --transport sse --port 3002`), add that server to **mcp.json** (e.g. `mcpServers.omniAgent.url = "http://127.0.0.1:3002"`), then start the Rust agent (it loads mcp.json by default). List env vars for inference only (OPENAI_API_KEY, LITELLM_PROXY_URL, etc.) if used; MCP is from mcp.json only. |
| **Deliverable** | User can start MCP server + Rust agent from docs; CLI is discoverable (--help).                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| **Deps**        | Steps 1–5.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |

---

## Step 7 — Session window (omni-window) — _Next_

| Field           | Content                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| --------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **What**        | Use **omni-window** for session history so the agent scales to 1k–10k turns without holding full message lists in memory. Aligns with Nanobot (bounded history) and ZeroClaw (session state).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| **Concrete**    | Add dependency `omni-window` to `omni-agent`. Per session_id: create or reuse a `SessionWindow` (ring buffer). After each turn: `append_turn` (turn metadata; refs to checkpoint or message IDs if needed). When building prompt: `get_recent_for_context(n)` (or equivalent) to get last N turns for the LLM. Keep or phase out in-memory `SessionStore` (e.g. use window as source of truth and derive messages for LLM from window + current turn). Config: `window_max_turns` (e.g. 2048). **Before implementing**: Review Nanobot and ZeroClaw session/history code; update [reference-nanobot-zeroclaw-review.md](./reference-nanobot-zeroclaw-review.md) §1 and avoid their pitfalls. |
| **Deliverable** | Gateway/stdio/repl use omni-window for session; long conversations (100+ turns) do not grow unbounded; context for LLM is built from window.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| **Deps**        | Step 1 (loop exists). `omni-window` crate exists (`SessionWindow`, `TurnSlot`).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |

---

## Step 8 — Consolidation when window full — _Done_

| Field           | Content                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| --------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **What**        | When the session window exceeds a threshold, **consolidate** the oldest segment into omni-memory (store_episode + mark_success/mark_failure) and trim the window. Same as Nanobot’s memory consolidation and [omni-run-react-gateway-design.md](./omni-run-react-gateway-design.md) §8.6.                                                                                                                                                                                                                                                                                                                                        |
| **Concrete**    | On `append_turn` (or periodically): if window size ≥ threshold, (1) take oldest segment (e.g. oldest 20% or last K turns), (2) summarise intent + key actions + outcome (e.g. via LLM or rule-based), (3) call `store_episode(intent, experience, outcome)` and optionally `mark_success`/`mark_failure` from omni-memory, (4) remove or rotate that segment from the window. Config: `consolidation_threshold_turns` (or tokens). **Before implementing**: Review Nanobot/ZeroClaw memory and consolidation; update [reference-nanobot-zeroclaw-review.md](./reference-nanobot-zeroclaw-review.md) §2 and avoid their pitfalls. |
| **Deliverable** | Long sessions write episodic memory into omni-memory; future runs benefit via two_phase_recall; window stays bounded. **Done**: omni-window `drain_oldest_turns`, agent `try_consolidate` after append.                                                                                                                                                                                                                                                                                                                                                                                                                          |
| **Deps**        | Step 5 (omni-memory in loop), Step 7 (omni-window).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |

---

## Summary table (for audit)

| Step  | Title                          | Deliverable                                                                                                                                                                                                                                                                                                                                                                                    |
| ----- | ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **1** | HTTP gateway                   | POST /message → agent reply; configurable listen + MCP list. **Done**.                                                                                                                                                                                                                                                                                                                         |
| **2** | Stdio mode                     | Read line from stdin → run turn → print reply. **Done**: `gateway/stdio.rs`, `run_stdio`; subcommand `stdio`.                                                                                                                                                                                                                                                                                  |
| **3** | MCP config: mcp.json           | Use universal mcp.json (mcpServers); --mcp-config path; same format as Cursor/Python. **Done**.                                                                                                                                                                                                                                                                                                |
| **4** | Multiple MCP servers           | Connect to N servers; merge tools; route tools/call to correct server. **Done**: qualified names `mcp__{server}__{tool}` when N>1.                                                                                                                                                                                                                                                             |
| **5** | omni-memory in loop            | two_phase_recall + store_episode in run_turn (core self-evolution). **Done**: optional `config.memory` (MemoryConfig), recall before LLM, store after success.                                                                                                                                                                                                                                 |
| **6** | CLI surface and docs           | **Done**: `omni-agent` binary (clap), subcommands `gateway` / `stdio` / `repl`, `--mcp-config`; README; inference from MCP URL when local.                                                                                                                                                                                                                                                     |
| **7** | Session window (omni-window)   | **Done.** Optional `config.window_max_turns` (e.g. 2048): when set, session history uses **omni-window** (`SessionWindowStore` + `SessionWindow`): ring buffer per session_id, `get_recent_messages(limit)` for LLM context, `append_turn(user, assistant, tool_count)`. Bounded; no full history in memory. See `session/window_store.rs`, `agent.rs` (window_store, append_turn tool_count). |
| **8** | Consolidation when window full | **Done.** When session window ≥ `consolidation_threshold_turns`, drain oldest `consolidation_take_turns` turns, summarise (intent/experience/outcome), store Episode and update_q(reward). omni-window `drain_oldest_turns`; agent `try_consolidate` after append.                                                                                                                             |

---

## Execution order and dependencies

```
Step 1 (HTTP gateway)     ✅ Done
Step 2 (Stdio)            ✅ Done
Step 3 (Config/CLI MCP)   ✅ Done
Step 4 (Multiple MCP)     ✅ Done
Step 5 (omni-memory)      ✅ Done
Step 6 (CLI + docs)       ✅ Done
Step 7 (omni-window)      ✅ Done
Step 8 (Consolidation)    ✅ Done
```

**All steps complete.** two_phase_recall is in run_turn; Nanobot/ZeroClaw parity achieved. Optional follow-ups: CLI integration (`omni agent --rust`, `omni gateway --rust`) — done; Phase 2/3 (Rust MCP server) — deferred.

---

**Reference**: [Omni Rust Agent Implementation](./omni-rust-agent-implementation.md) (Phase C, D), [Next Steps: Rust Core and MCP](./next-steps-rust-core-and-mcp.md) (Phase 1). **Alignment**: [Nanobot/ZeroClaw Alignment](./nanobot-zeroclaw-alignment.md) (feature parity + where we optimize better).
