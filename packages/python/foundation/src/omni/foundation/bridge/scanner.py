"""
scanner.py - Skill Index Reader (Migration Step 1)

This module implements the "Reader" part of the Rust-First Indexing architecture.
It reads the pre-generated `skills-index.json` (Single Source of Truth) instead
of scanning the file system or parsing TOML files at runtime.

Migration Context:
- Source: skills-index.json (Generated by `omni skill sync`)
- Consumer: Python Kernel (via this module)
- Logic: Read-Only, Fast Startup
"""

from __future__ import annotations

import json
import os
from pathlib import Path
from typing import Any

from omni.foundation.config.logging import get_logger

logger = get_logger("omni.foundation.scanner")


class SnifferRule:
    """Represents a single sniffer rule loaded from the index."""

    def __init__(self, rule_type: str, pattern: str):
        self.rule_type = rule_type  # "file_exists" or "file_pattern"
        self.pattern = pattern

    def __repr__(self) -> str:
        return f"SnifferRule(type={self.rule_type}, pattern={self.pattern})"

    def to_dict(self) -> dict[str, str]:
        return {"type": self.rule_type, "pattern": self.pattern}


class DiscoveredSkillRules:
    """Rules and metadata for a skill loaded from the index."""

    def __init__(
        self,
        skill_name: str,
        skill_path: str,
        rules: list[SnifferRule] | None = None,
        metadata: dict[str, Any] | None = None,
    ):
        self.skill_name = skill_name
        self.skill_path = skill_path
        self.rules = rules or []
        self.metadata = metadata or {}

    def __repr__(self) -> str:
        return f"DiscoveredSkillRules({self.skill_name}, {len(self.rules)} rules)"

    def to_list_of_dicts(self) -> list[dict[str, str]]:
        return [rule.to_dict() for rule in self.rules]


class PythonSkillScanner:
    """
    Skill Index Reader.

    Replaces the legacy file-system scanner. This class now strictly reads
    from the `skills-index.json` file generated by the Rust build tools.
    """

    def __init__(self, index_path: str | None = None):
        self._index_path = index_path or self._resolve_index_path()

    @property
    def index_path(self) -> str:
        """Get the path to the skills index file."""
        return self._index_path

    def _resolve_index_path(self) -> str:
        """
        Resolve the path to skills-index.json.
        Priority:
        1. OMNI_SKILL_INDEX environment variable
        2. .cache/skill_index.json (New location - cache directory)
        3. assets/skills/skill_index.json (Legacy location - deprecated)
        """
        env_path = os.environ.get("OMNI_SKILL_INDEX")
        if env_path:
            return env_path

        # Try to find the index file
        cwd = Path.cwd()

        # Potential paths to check (new location first, then legacy)
        candidates = [
            cwd / ".cache" / "skill_index.json",  # New location (cache directory)
            cwd / "assets" / "skills" / "skill_index.json",  # Legacy location
            cwd / "assets" / "skills-index.json",  # Alternative structure
            # Fallback for when running inside packages/python/...
            cwd.parents[0] / ".cache" / "skill_index.json",
            cwd.parents[0] / "assets" / "skills" / "skill_index.json",
            cwd.parents[1] / ".cache" / "skill_index.json",
            cwd.parents[1] / "assets" / "skills" / "skill_index.json",
        ]

        for path in candidates:
            if path.exists():
                logger.debug(f"Found skill index at: {path}")
                return str(path)

        # Default fallback (even if not exists, to report error later)
        return str(cwd / ".cache" / "skill_index.json")

    def scan_directory(self, base_path: str = "") -> list[DiscoveredSkillRules]:
        """
        Load skills from the configured JSON index.

        Args:
            base_path: Ignored in the new architecture, kept for API compatibility.
        """
        if not os.path.exists(self._index_path):
            logger.error(
                f"Skill index not found at: {self._index_path}. Please run `omni skill sync`."
            )
            return []

        try:
            with open(self._index_path, encoding="utf-8") as f:
                data = json.load(f)

            skills = []
            for item in data:
                skill_name = item.get("name")
                # Handle both "path" (legacy) and future "abspath" scenarios
                skill_path = item.get("path", "")

                # Parse sniffing rules if present (New Schema)
                rules_data = item.get("sniffing_rules", [])
                rules = []
                for r in rules_data:
                    if "type" in r and "pattern" in r:
                        rules.append(SnifferRule(r["type"], r["pattern"]))

                metadata = item.get("metadata", {})
                # Backwards compatibility: flatten top-level fields into metadata if missing
                if not metadata:
                    metadata = {
                        "version": item.get("version", "0.0.0"),
                        "description": item.get("description", ""),
                    }
                # Always include top-level fields that should be in metadata
                if "routingKeywords" in item:
                    metadata["routingKeywords"] = item["routingKeywords"]
                if "intents" in item:
                    metadata["intents"] = item["intents"]
                if "authors" in item:
                    metadata["authors"] = item["authors"]
                # Include tools in metadata for skill_info command
                if "tools" in item:
                    metadata["tools"] = item["tools"]

                skill_entry = DiscoveredSkillRules(
                    skill_name=skill_name,
                    skill_path=skill_path,
                    rules=rules,
                    metadata=metadata,
                )
                skills.append(skill_entry)

            logger.info(f"Loaded {len(skills)} skills from index: {self._index_path}")
            return skills

        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse skill index JSON: {e}")
            return []
        except Exception as e:
            logger.error(f"Error reading skill index: {e}")
            return []

    def parse_skill_metadata(self, skill_path: str) -> dict[str, Any]:
        """
        Retrieve metadata for a specific skill from the loaded index.
        Note: This is less efficient than getting it from scan_directory
        but kept for interface compatibility.
        """
        skills = self.scan_directory()
        for skill in skills:
            if skill.skill_path == skill_path or skill.skill_path.endswith(
                os.path.basename(skill_path)
            ):
                return skill.metadata

        return {"name": os.path.basename(skill_path)}


def scan_skills_with_rules(base_path: str = "") -> list[DiscoveredSkillRules]:
    """Convenience function to load skills from index."""
    scanner = PythonSkillScanner()
    return scanner.scan_directory(base_path)


__all__ = [
    "DiscoveredSkillRules",
    "PythonSkillScanner",
    "SnifferRule",
    "scan_skills_with_rules",
]
