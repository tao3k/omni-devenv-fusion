"""
omni.core.skills.discovery - Skill Discovery Module

High-performance skill discovery using Rust-generated Index.
Replaces live file system scanning with Read-Only Index consumption.

Architecture:
    Index (JSON) -> Foundation (Reader) -> Core (Discovery) -> Kernel

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ skill_index.jsonâ”‚  â† Generated by Rust Scanner
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼ Reads
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚PythonSkillScannerâ”‚  â† Foundation Layer (Index Reader)
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼ Returns
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚DiscoveredSkill  â”‚  â† Core Layer (Discovery Service)
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼ Used by
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   Kernel        â”‚  â† Consumes DiscoveredSkill objects
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
"""

import os
from typing import Any

from omni.foundation.bridge.scanner import (
    DiscoveredSkillRules,
    PythonSkillScanner,
)
from omni.foundation.config.logging import get_logger
from pydantic import BaseModel

logger = get_logger("omni.core.discovery")


class DiscoveredSkill(BaseModel):
    """Represents a discovered skill with its metadata.

    Created from Foundation's DiscoveredSkillRules via from_index_entry().
    """

    name: str
    path: str
    metadata: dict[str, Any]
    has_extensions: bool = False

    @classmethod
    def from_index_entry(cls, entry: DiscoveredSkillRules) -> "DiscoveredSkill":
        """Create from Foundation DiscoveredSkillRules object.

        Args:
            entry: DiscoveredSkillRules from PythonSkillScanner.scan_directory()

        Returns:
            DiscoveredSkill instance
        """
        # Check for extensions directory
        has_ext = False
        if entry.skill_path:
            ext_path = os.path.join(entry.skill_path, "extensions")
            has_ext = os.path.isdir(ext_path)

        return cls(
            name=entry.skill_name,
            path=entry.skill_path,
            metadata=entry.metadata,
            has_extensions=has_ext,
        )

    @classmethod
    def from_dict(cls, data: dict[str, Any], name: str, path: str) -> "DiscoveredSkill":
        """Create from raw dictionary (for testing/fallback).

        Args:
            data: Dictionary with skill metadata
            name: Skill name
            path: Skill path

        Returns:
            DiscoveredSkill instance
        """
        has_ext = os.path.isdir(os.path.join(path, "extensions"))
        return cls(
            name=name,
            path=path,
            metadata=data,
            has_extensions=has_ext,
        )


class ToolMatch(BaseModel):
    """Represents a tool matching a search query."""

    name: str
    skill_name: str
    description: str
    score: float
    matched_intent: str
    usage_template: str = ""


class SkillDiscoveryService:
    """
    Level 2: Skill Discovery Service.

    Coordinates skill discovery using the Single Source of Truth (Index).
    This provides O(1) discovery time regardless of skill count.

    Usage:
        service = SkillDiscoveryService()
        skills = service.discover_all()  # Reads skill_index.json
        for skill in skills:
            print(f"Found: {skill.name}")

        # Search for tools
        matches = service.search_tools(query="read file", limit=3)
    """

    def __init__(self):
        """Initialize the discovery service with Index Reader."""
        self._scanner = PythonSkillScanner()
        self._index: list[dict] | None = None

    def _load_index(self) -> list[dict]:
        """Load the skill index (cached)."""
        if self._index is not None:
            return self._index

        index_entries = self._scanner.scan_directory()
        self._index = []
        for entry in index_entries:
            metadata = entry.metadata or {}
            self._index.append(
                {
                    "skill_name": entry.skill_name,
                    "skill_path": entry.skill_path,
                    "description": metadata.get("description", ""),
                    "routing_keywords": metadata.get("routingKeywords", [])
                    or metadata.get("routing_keywords", []),
                    "intents": metadata.get("intents", []) or [],
                    "tools": metadata.get("tools", []) or [],
                }
            )
        return self._index

    def search_tools(self, query: str, limit: int = 3, threshold: float = 0.3) -> list[ToolMatch]:
        """
        Search for tools matching the given intent/query.

        Uses hybrid matching (keywords + intents) to find the best tools.

        Args:
            query: Natural language intent (e.g., "read markdown files")
            limit: Maximum number of results to return
            threshold: Minimum score threshold (0.0-1.0)

        Returns:
            List of ToolMatch objects sorted by score
        """
        index = self._load_index()
        query_lower = query.lower()
        query_words = set(query_lower.split())

        matches: list[tuple[ToolMatch, float]] = []

        for skill in index:
            skill_name = skill["skill_name"]
            description = skill.get("description", "")

            # Check skill-level matches (keywords and intents)
            skill_score = 0.0

            # Keyword matching
            keywords = skill.get("routing_keywords", [])
            for kw in keywords:
                kw_lower = kw.lower()
                if kw_lower in query_lower:
                    skill_score = max(skill_score, 0.5)
                elif any(word in kw_lower for word in query_words if len(word) > 3):
                    skill_score = max(skill_score, 0.3)

            # Intent matching
            intents = skill.get("intents", [])
            for intent in intents:
                intent_lower = intent.lower()
                if intent_lower in query_lower or query_lower in intent_lower:
                    skill_score = max(skill_score, 0.7)

            # Check tool-level matches
            tools = skill.get("tools", [])
            for tool in tools:
                tool_name = tool.get("name", "")
                tool_desc = tool.get("description", "")

                tool_score = skill_score

                # Direct name match (highest priority)
                if query_lower.replace(" ", "_") in tool_name.lower():
                    tool_score = max(tool_score, 0.95)
                elif query_lower.replace(" ", "") in tool_name.lower().replace("_", "").replace(
                    ".", ""
                ):
                    tool_score = max(tool_score, 0.85)

                # Keyword-based scoring for install/jit scenarios
                if "install" in query_lower and "jit_install" in tool_name:
                    tool_score = max(tool_score, 0.9)
                elif "install" in query_lower and "install" in tool_name.lower():
                    tool_score = max(tool_score, 0.85)

                # SPECIAL: skill.discover should be boosted for uncertainty queries
                # This implements the "Discovery First" rule from intent_protocol.md
                if tool_name == "skill.discover":
                    # Boost for queries about capabilities, tools, learning, analyzing
                    uncertainty_keywords = [
                        "analyze",
                        "learn",
                        "what can",
                        "available",
                        "capability",
                        "tools",
                        "commands",
                        "find",
                        "search",
                        "discover",
                        "look up",
                        "look up",
                        "how to",
                        "which tool",
                        "what tool",
                    ]
                    for keyword in uncertainty_keywords:
                        if keyword in query_lower:
                            tool_score = max(tool_score, 0.85)
                            break
                    else:
                        # Default boost for discover - it's the fallback for uncertainty
                        tool_score = max(tool_score, 0.6)

                # Check if query words appear in tool name
                for word in query_words:
                    if word in tool_name.lower() and len(word) > 3:
                        tool_score = max(tool_score, 0.7)

                # Description match (lower priority)
                if query_lower in tool_desc.lower():
                    tool_score = max(tool_score, 0.6)

                if tool_score >= threshold:
                    # Build usage template with @omni format
                    # For jit_install: use @omni("skill.jit_install", {"skill_id": "..."})
                    # For regular tools: use @omni("tool.name", {"param": "..."})
                    if tool_name == "skill.jit_install":
                        usage = '@omni("skill.jit_install", {"skill_id": "<skill-name>"})'
                    else:
                        usage = f'@omni("{tool_name}", {{"..."}})'

                    match = ToolMatch(
                        name=tool_name,
                        skill_name=skill_name,
                        description=tool_desc,
                        score=tool_score,
                        matched_intent=query,
                        usage_template=usage,
                    )
                    matches.append((match, tool_score))

        # Sort by score and limit
        matches.sort(key=lambda x: x[1], reverse=True)
        return [m[0] for m in matches[:limit]]

    def discover_all(self, locations: list[str] | None = None) -> list[DiscoveredSkill]:
        """Discover all skills from the Index.

        Args:
            locations: Ignored in Rust-First Indexing (kept for API compat).
                       The index location is resolved by the Foundation layer.

        Returns:
            List of DiscoveredSkill objects sorted by name.
        """
        logger.debug("ðŸ” Accessing Skill Index...")

        # Use Foundation Layer to read JSON Index
        index_entries = self._scanner.scan_directory()

        all_skills = []
        for entry in index_entries:
            skill = DiscoveredSkill.from_index_entry(entry)
            all_skills.append(skill)

        # Sort by name for consistent ordering
        all_skills.sort(key=lambda s: s.name)

        logger.info(f"ðŸ“¦ Index Service provided {len(all_skills)} skills")
        return all_skills

    def discover_one(self, skill_name: str) -> DiscoveredSkill | None:
        """Find a single skill in the Index by name.

        Args:
            skill_name: Name of the skill to find.

        Returns:
            DiscoveredSkill if found, None otherwise.
        """
        # This scans the in-memory list (fast enough for now)
        skills = self.discover_all()
        for skill in skills:
            if skill.name == skill_name:
                return skill
        return None

    def get_skills_with_extensions(self) -> list[DiscoveredSkill]:
        """Get all skills that have extensions directory."""
        skills = self.discover_all()
        return [s for s in skills if s.has_extensions]


def is_rust_available() -> bool:
    """Check if Rust bindings are available.

    Note: In Rust-First Indexing, this returns True if the index
    was generated by the Rust scanner (which is always the case now).
    """
    return True


__all__ = [
    "DiscoveredSkill",
    "SkillDiscoveryService",
    "ToolMatch",
    "is_rust_available",
]
