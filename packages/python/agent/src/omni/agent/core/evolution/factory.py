"""
factory.py - Automated Skill Synthesis

Core Logic: Generate standard Omni Skill files from candidate patterns.

Safety: All generated skills go to quarantine directory for review.
"""

from pathlib import Path
from typing import List

from omni.foundation.config.logging import get_logger

from .harvester import CandidateSkill

logger = get_logger("omni.evolution.factory")


# Standard skill template with proper structure
SKILL_TEMPLATE = '''"""
{skill_name} - Auto-generated by Omni-Dev Fusion Factory

{description}

Generated: {timestamp}
"""

from typing import Any
from omni.core.skills import skill, tool


@skill(
    name="{skill_name}",
    description="{description}",
    tags=["auto-generated", "harvested"]
)
class {class_name}:
    """
    {description}

    Generated by Omni-Dev Fusion Factory from observed workflow patterns.
    """

    @tool
    async def run(
        self,
        ctx: Any,
        {params}
    ) -> str:
        """
        Execute the {skill_name} workflow.

        {param_docs}

        Returns:
            Result of the workflow execution
        """
        # TODO: Implement skill logic based on harvested workflow:
        # {workflow_summary}
        #
        # Variables identified: {variables}
        raise NotImplementedError("Auto-generated skill requires manual implementation")


# Quality gates for generated skills:
# 1. All skills go to quarantine first
# 2. Must pass static analysis before promotion
# 3. Requires at least one integration test
'''

PARAM_TEMPLATE = """{param_name}: str = None,  # {param_description}"""


class SkillFactory:
    """
    Synthesizes executable Python skills from abstract definitions.

    Safety First:
    - All generated skills go to `quarantine/` directory
    - Must be reviewed/promoted before becoming active
    """

    @staticmethod
    def _sanitize_name(name: str) -> str:
        """Convert intent string to valid Python identifier."""
        # Convert to snake_case
        safe = name.lower().strip()
        safe = safe.replace(" ", "_").replace("-", "_").replace(".", "_")
        # Remove any non-alphanumeric characters (keep underscores)
        safe = "".join(c if c.isalnum() or c == "_" else "_" for c in safe)
        # Ensure it doesn't start with a number
        if safe[0].isdigit():
            safe = f"skill_{safe}"
        return safe

    @staticmethod
    def _to_class_name(snake_name: str) -> str:
        """Convert snake_case to PascalCase."""
        parts = snake_name.split("_")
        return "".join(p.title() for p in parts if p)

    @staticmethod
    def synthesize(candidate: CandidateSkill, output_dir: Path) -> str:
        """
        Core Algorithm:
        1. Name Sanitization: Convert intent to snake_case
        2. Parameter Mapping: Map extracted variables to function arguments
        3. Code Generation: Generate the skill file
        4. Persistence: Write to quarantine directory

        Args:
            candidate: Extracted skill candidate from Harvester
            output_dir: Base output directory (e.g., SKILLS_DIR() / "harvested")

        Returns:
            Path to the generated skill file
        """
        # 1. Name sanitization
        safe_name = SkillFactory._sanitize_name(candidate.intent)
        class_name = SkillFactory._to_class_name(safe_name)

        # 2. Map variables to parameters
        param_list: List[str] = []
        param_docs_list: List[str] = []
        for var in candidate.variables:
            param_name = SkillFactory._sanitize_name(var)
            param_list.append(f"{param_name}: str = None")
            param_docs_list.append(f"- {param_name}: Variable extracted from workflow")

        params_str = ",\n        ".join(param_list)
        param_docs_str = "\n        ".join(param_docs_list)

        # 3. Generate workflow summary
        workflow_summary = " -> ".join(tc.get("tool", "unknown") for tc in candidate.tool_chain[:5])
        if len(candidate.tool_chain) > 5:
            workflow_summary += f" (+{len(candidate.tool_chain) - 5} more)"

        # 4. Generate file content
        from datetime import datetime

        timestamp = datetime.now().isoformat()

        content = SKILL_TEMPLATE.format(
            skill_name=safe_name,
            description=candidate.description,
            class_name=class_name,
            params=params_str,
            param_docs=param_docs_str,
            workflow_summary=workflow_summary,
            variables=candidate.variables,
            timestamp=timestamp,
        )

        # 5. Write to quarantine directory (safety first)
        quarantine_dir = output_dir / "quarantine"
        quarantine_dir.mkdir(parents=True, exist_ok=True)

        file_path = quarantine_dir / f"{safe_name}.py"
        file_path.write_text(content)

        logger.info(f"ğŸ§¬ Synthesized skill: {file_path}")
        return str(file_path)

    @staticmethod
    def generate_skill_code(
        skill_name: str,
        description: str,
        tool_chain: list[dict],
        variables: list[str],
        implementation_hint: str = "",
    ) -> str:
        """
        Generate skill code without writing to disk.

        Useful for preview or testing purposes.

        Args:
            skill_name: Name of the skill
            description: Human-readable description
            tool_chain: List of tool definitions
            variables: List of variable names
            implementation_hint: Optional hint for implementation

        Returns:
            Generated Python code as string
        """
        safe_name = SkillFactory._sanitize_name(skill_name)
        class_name = SkillFactory._to_class_name(safe_name)

        param_list = [f"{SkillFactory._sanitize_name(v)}: str = None" for v in variables]
        params_str = ",\n        ".join(param_list)

        workflow_summary = " -> ".join(tc.get("tool", "unknown") for tc in tool_chain)

        return SKILL_TEMPLATE.format(
            skill_name=safe_name,
            description=description,
            class_name=class_name,
            params=params_str,
            param_docs=f"- Generated from {len(tool_chain)} tool calls\n        "
            + "\n        ".join(f"- {SkillFactory._sanitize_name(v)}: variable" for v in variables),
            workflow_summary=workflow_summary,
            variables=variables,
            timestamp="",
        )

    @staticmethod
    def create_skill_md(candidate: CandidateSkill, skill_file_path: Path) -> str:
        """
        Generate SKILL.md documentation for a harvested skill.

        Args:
            candidate: The skill candidate
            skill_file_path: Path to the generated Python file

        Returns:
            Path to the generated documentation file
        """
        # For now, just log that documentation should be created
        logger.info(f"ğŸ“ Skill documentation should be created for {candidate.intent}")
        return ""
