"""
skill_memory.py - Persistent Skill Memory for Agent Context.

Reads skill-index.json for skill metadata (including require_refs) and
SKILL.md for skill protocol content.

Schema-Driven: Uses skill_metadata.schema.json for metadata validation.
The require_refs field is read from skill-index.json (generated by scanning).
"""

from __future__ import annotations

import json
import structlog
from pathlib import Path
from typing import Any, Dict, List, Optional

logger = structlog.get_logger(__name__)


class SkillMemory:
    """
    Skill Memory - Reads skill-index.json for metadata and SKILL.md for protocols.

    Provides:
    - Core Skills: Preloaded skills that are always available (git, memory, knowledge)
    - Active Skills: Skills relevant to the current task
    - Require Refs: External docs declared in SKILL.md frontmatter (via skill-index.json)
    """

    def __init__(self) -> None:
        self._core_skills: Optional[set[str]] = None
        self._skills_dir: Optional[Path] = None
        self._skill_index: Optional[List[Dict[str, Any]]] = None
        self._skill_refs_cache: Dict[str, List[str]] = {}

    def _get_skills_dir(self) -> Path:
        """Get skills directory path."""
        if self._skills_dir is None:
            from common.skills_path import SKILLS_DIR

            self._skills_dir = SKILLS_DIR()
        return self._skills_dir

    def _get_skill_index(self) -> List[Dict[str, Any]]:
        """Load skill_index.json (lazily)."""
        if self._skill_index is None:
            skills_dir = self._get_skills_dir()
            index_path = skills_dir / "skill_index.json"

            if index_path.exists():
                try:
                    index_data = json.loads(index_path.read_text(encoding="utf-8"))
                    self._skill_index = index_data if isinstance(index_data, list) else []
                    logger.debug(f"SkillMemory: Loaded {len(self._skill_index)} skills from index")
                except Exception as e:
                    logger.warning(f"SkillMemory: Failed to load skill_index.json: {e}")
                    self._skill_index = []
            else:
                logger.warning(f"SkillMemory: skill_index.json not found at {index_path}")
                self._skill_index = []

        return self._skill_index

    def _get_skill_metadata(self, skill_name: str) -> Optional[Dict[str, Any]]:
        """Get metadata for a specific skill from the index."""
        for skill in self._get_skill_index():
            # The index uses "name" field, not "skill_name"
            if skill.get("name") == skill_name:
                return skill
        return None

    def _get_core_skills(self) -> set[str]:
        """Get preloaded core skills from settings."""
        if self._core_skills is None:
            try:
                from common.config.settings import get_setting

                self._core_skills = set(
                    get_setting("skills.preload", ["knowledge", "memory", "git"])
                )
            except Exception:
                # Default core skills
                self._core_skills = {"knowledge", "memory", "git"}

        return self._core_skills

    def _read_skill_md(self, skill_name: str) -> Optional[str]:
        """Read SKILL.md for a skill."""
        skills_dir = self._get_skills_dir()
        skill_path = skills_dir / skill_name

        if not skill_path.exists():
            logger.debug(f"Skill path not found: {skill_path}")
            return None

        md_path = skill_path / "SKILL.md"
        if not md_path.exists():
            logger.debug(f"SKILL.md not found for skill: {skill_name}")
            return None

        try:
            content = md_path.read_text(encoding="utf-8")
            return content
        except Exception as e:
            logger.warning(f"Failed to read SKILL.md for {skill_name}: {e}")
            return None

    def get_require_refs(self, skill_name: str) -> list[str]:
        """
        Get require_refs for a skill from skill-index.json.

        Args:
            skill_name: The skill to get refs for

        Returns:
            List of reference paths declared in frontmatter
        """
        if skill_name in self._skill_refs_cache:
            return self._skill_refs_cache[skill_name]

        metadata = self._get_skill_metadata(skill_name)
        if metadata:
            # Rust uses camelCase for JSON field names
            refs = metadata.get("requireRefs", [])
        else:
            # Fallback: try reading SKILL.md directly (for backward compatibility)
            content = self._read_skill_md(skill_name)
            if content:
                refs = self._parse_frontmatter_refs(content)
            else:
                refs = []

        self._skill_refs_cache[skill_name] = refs

        if refs:
            logger.debug(f"SkillMemory: Found {len(refs)} require_refs for {skill_name}")

        return refs

    def _parse_frontmatter_refs(self, content: str) -> list[str]:
        """Parse require_refs from SKILL.md frontmatter (fallback)."""
        import re

        match = re.match(r"^---\n(.*?)\n---", content, re.DOTALL)
        if match:
            try:
                import yaml

                frontmatter = yaml.safe_load(match.group(1)) or {}
                return frontmatter.get("require_refs", [])
            except Exception:
                pass
        return []

    def get_all_require_refs(
        self, active_skills: Optional[set[str]] = None
    ) -> dict[str, list[str]]:
        """
        Get all require_refs for given skills.

        Args:
            active_skills: Skills to get refs for (includes all if None)

        Returns:
            Dict mapping skill_name -> list of ref paths
        """
        result: dict[str, list[str]] = {}

        # Get all skills (core + active)
        all_skills = self._get_core_skills()
        if active_skills:
            all_skills = all_skills | active_skills

        for skill_name in all_skills:
            refs = self.get_require_refs(skill_name)
            if refs:
                result[skill_name] = refs

        return result

    def get_core_prompts(self) -> Dict[str, str]:
        """
        Get SKILL.md content for all preloaded core skills.

        These skills are always available and their protocols should
        always be injected into context.
        """
        core_skills = self._get_core_skills()
        prompts: Dict[str, str] = {}

        for skill_name in core_skills:
            content = self._read_skill_md(skill_name)
            if content:
                prompts[skill_name] = content
                logger.debug(f"SkillMemory: Loaded core skill {skill_name}")

        logger.info(f"SkillMemory: Loaded {len(prompts)} core skills")
        return prompts

    def get_active_prompts(self, active_skills: set[str]) -> Dict[str, str]:
        """
        Get SKILL.md content for task-relevant active skills.

        Args:
            active_skills: Set of skill names relevant to current task
        """
        prompts: Dict[str, str] = {}

        for skill_name in active_skills:
            # Skip core skills (already loaded)
            if skill_name in self._get_core_skills():
                continue

            content = self._read_skill_md(skill_name)
            if content:
                prompts[skill_name] = content
                logger.debug(f"SkillMemory: Loaded active skill {skill_name}")

        logger.info(f"SkillMemory: Loaded {len(prompts)} active skills")
        return prompts

    def get_all_prompts(self, active_skills: Optional[set[str]] = None) -> Dict[str, str]:
        """
        Get all skill prompts (Core + Active).

        Note: References are documented in SKILL.md frontmatter (require_refs).
        Use get_all_require_refs() to get reference paths.

        Args:
            active_skills: Optional set of task-relevant skills

        Returns:
            Dict mapping skill_name -> SKILL.md content
        """
        # Always include core skills
        all_prompts = self.get_core_prompts()

        # Add active skills if provided
        if active_skills:
            active_prompts = self.get_active_prompts(active_skills)
            all_prompts.update(active_prompts)

        return all_prompts


# Singleton accessor
_skill_memory: SkillMemory | None = None


def get_skill_memory() -> SkillMemory:
    """Get the singleton SkillMemory instance."""
    global _skill_memory
    if _skill_memory is None:
        _skill_memory = SkillMemory()
    return _skill_memory


__all__ = ["SkillMemory", "get_skill_memory"]
