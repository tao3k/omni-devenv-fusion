# Justfile for devenv-native
# https://github.com/casey/just
#
# Design principles:
# - Interactive commands for humans (e.g., `just commit`)
# - Agent-friendly commands with `agent-*` prefix (e.g., `just agent-commit "feat" "cli" "message"`)
# - SRE health checks with JSON output for machine parsing
# - Group annotations for clean `just --list` output

# ==============================================================================
# Global Settings
# ==============================================================================

set dotenv-load := true
set shell := ["bash", "-uc"]
set positional-arguments := true

# Enable JSON output mode via environment variable
json_output := if env_var_or_default("JUST_JSON", "false") == "true" { "true" } else { "false" }

# ==============================================================================
# Core Commands
# ==============================================================================

default:
    @just --list

# ==============================================================================
# AGENT INTERFACE (Non-interactive, argument-based)
# Designed for AI agents - accepts parameters, no interactive prompts
# ==============================================================================

# Non-interactive commit for agents
# Usage: just agent-commit
# Reads commit message from token file generated by smart_commit MCP tool
agent-commit:
    #!/usr/bin/env bash
    set -euo pipefail

    # Token file path (must match commit.py)
    TOKEN_FILE="/tmp/.omni_commit_token"

    # Check if token exists and is valid (only from smart_commit workflow)
    if [ ! -f "$TOKEN_FILE" ]; then
        echo "Error: No authorization token found." >&2
        echo "" >&2
        echo "To commit, you must:" >&2
        echo "1. Use the smart_commit MCP tool first: @omni-orchestrator smart_commit(context='...')" >&2
        echo "2. Then run: just agent-commit" >&2
        exit 1
    fi

    # Read token content: format is session_id:token:timestamp:message
    TOKEN_CONTENT=$(cat "$TOKEN_FILE")
    SESSION_ID=$(echo "$TOKEN_CONTENT" | cut -d':' -f1)
    TOKEN=$(echo "$TOKEN_CONTENT" | cut -d':' -f2)
    TIMESTAMP=$(echo "$TOKEN_CONTENT" | cut -d':' -f3)
    # Message may contain colons, so use the 4th field to end
    MSG=$(echo "$TOKEN_CONTENT" | cut -d':' -f4-)

    # Validate token is not empty
    if [ -z "$TOKEN" ]; then
        echo "Error: Invalid authorization token (empty)." >&2
        rm -f "$TOKEN_FILE"
        exit 1
    fi

    # Check token expiration (5 minutes)
    TOKEN_EPOCH=$(date -d "$TIMESTAMP" +%s 2>/dev/null || date +%s)
    NOW_EPOCH=$(date +%s)
    ELAPSED=$((NOW_EPOCH - TOKEN_EPOCH))
    if [ $ELAPSED -gt 300 ]; then
        echo "Error: Authorization token has expired." >&2
        rm -f "$TOKEN_FILE"
        exit 1
    fi

    echo "Commit message: $MSG"
    echo ""

    # Run lefthook first to apply all formatting fixes (prevents unstaged files after commit)
    echo "Running pre-commit hooks..."
    lefthook run pre-commit --all-files --no-tty

    # Re-stage all files after formatting (prettier modifies files but doesn't auto-stage)
    echo "Re-staging all modified files..."
    git add -A

    # Run tests before commit
    echo "Running tests..."
    devenv test

    # Stage again after tests (in case tests modify files)
    echo "Staging all files..."
    git add -A

    # Commit with staged changes
    git commit -m "$MSG"

    # Consume the token (invalidate it)
    rm -f "$TOKEN_FILE"

    echo ""
    echo "Committed: $MSG"

# Agent-friendly validate (non-interactive)
agent-validate:
    @echo "Running validation..." && lefthook run pre-commit && devenv test

# Agent-friendly validate with git status output (safe - no commit)
# Usage: just agent-test-status
# This command runs tests and outputs git status for agent to read
agent-test-status:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "=== TEST_START ==="
    devenv test
    TEST_RESULT=$?
    echo "=== TEST_END ==="
    echo "=== GIT_STATUS_START ==="
    git status --short
    echo "=== GIT_STATUS_END ==="
    echo "=== GIT_LOG_START ==="
    git log --oneline -3
    echo "=== GIT_LOG_END ==="
    if [ $TEST_RESULT -eq 0 ]; then
        echo "Tests passed"
    else
        echo "Tests failed"
    fi
    exit $TEST_RESULT

# Agent-friendly format (apply fixes)
agent-fmt:
    @echo "Applying formatting fixes..." && lefthook run pre-commit --all-files --no-tty

# Agent-friendly version bump
agent-bump type="auto":
    #!/usr/bin/env bash
    set -euo pipefail
    BUMP_TYPE="{{type}}"
    if [ "$BUMP_TYPE" = "auto" ]; then
        cog bump --auto
    else
        cog bump --$BUMP_TYPE
    fi

# Agent-friendly release publish
agent-publish-release version="latest":
    #!/usr/bin/env bash
    set -euo pipefail
    VERSION="{{version}}"
    if [ "$VERSION" = "latest" ]; then
        VERSION=$(git describe --tags --abbrev=0)
    fi
    NOTES=$(mktemp)
    just release-notes "$VERSION" > "$NOTES"
    gh release create "$VERSION" --title "Release $VERSION" --notes-file "$NOTES" --verify-tag
    rm -f "$NOTES"

# Agent-friendly complete release workflow
agent-release type="auto" version="latest":
    #!/usr/bin/env bash
    set -euo pipefail
    just agent-validate
    just agent-bump {{type}}
    just agent-publish-release {{version}}

# ==============================================================================
# ðŸ¤– AGENT WORKFLOW AUTOMATION
# ==============================================================================

# Generate high-density context dump for agent startup
[no-exit-message]
agent-context:
    @echo "<project_context_dump>"
    @echo "=== ðŸ“‹ CURRENT MISSION (Backlog Top 20) ==="
    @head -n 20 Backlog.md 2>/dev/null || echo "âš ï¸ No Backlog.md found. Create one to drive the agent."
    @echo ""
    @echo "=== ðŸš¦ GIT STATUS ==="
    @git status --short --branch
    @echo ""
    @echo "=== âš™ï¸ RULES (cog.toml scopes) ==="
    @grep -A 20 "scopes =" cog.toml 2>/dev/null | head -15 || echo "cog.toml not found"
    @echo ""
    @echo "=== ðŸ“ RECENT COMMITS ==="
    @git log --oneline -5
    @echo ""
    @echo "=== âœï¸ WRITING STYLE (agent/writing-style/) ==="
    @ls -1 agent/writing-style/*.md 2>/dev/null | xargs -I {} basename {} .md | sed 's/^/  - /' || echo "  No style guides found"
    @echo "  Hint: Use 'writer.polish_text' to enforce these rules"
    @echo ""
    @echo "</project_context_dump>"
    @echo ""
    @echo "ðŸ’¡ INSTRUCTION: Read the context above. Identify the active task from Backlog.md and check if it aligns with git status. Await user command."

# ==============================================================================
# ðŸ§  COGNITION & SPECS
# ==============================================================================

# Focus Mode: Load specific Spec and prepare for development
# Usage: just agent-focus assets/specs/feature_name.md
agent-focus spec_path:
    @echo "ðŸš€ Focusing Agent on Spec: {{spec_path}}..."
    @echo ""
    @echo "=== ðŸŽ¯ FOCUS TARGET: {{spec_path}} ==="
    @cat {{spec_path}}
    @echo ""
    @echo "=== ðŸ—ï¸ RELATED CODE STRUCTURE ==="
    @echo "packages/python/agent modules:"
    @ls -1 packages/python/agent/src/agent/*.py 2>/dev/null | xargs -I {} basename {} .py | sed 's/^/  - /' || echo "  No modules found"
    @echo "agent/skills modules:"
    @ls -1 agent/skills/ 2>/dev/null | grep -v "^_" | sed 's/^/  - /' || echo "  No skills found"
    @echo ""
    @echo "=== ðŸ“‹ BACKLOG ALIGNMENT ==="
    @grep -i "$(basename {{spec_path}} .md)" Backlog.md 2>/dev/null || echo "  No matching backlog entry found"
    @echo ""
    @echo "ðŸ’¡ INSTRUCTION: Review the Spec above. Create a PLAN in 'SCRATCHPAD.md' before modifying any code."
    @echo "SCRATCHPAD Location: .cache/omni-dev-fusion/.memory/active_context/SCRATCHPAD.md"

# Quick create new Spec from template
# Usage: just spec-new "feature_name" "Feature description..."
spec-new name description:
    @echo "ðŸ—ï¸ Scaffolding Spec: {{name}}..."
    @cp assets/specs/template.md assets/specs/{{name}}.md
    @( \
        echo "=== ðŸ“ TASK: DRAFT SPEC ==="; \
        echo "Target File: assets/specs/{{name}}.md"; \
        echo "Feature Name: {{name}}"; \
        echo "User Description: {{description}}"; \
        echo ""; \
        echo "ðŸ’¡ INSTRUCTION: Read the 'Target File' template. Fill in Sections 1 (Context) and 2 (Architecture) based on the 'User Description'. Leave Section 3 (Plan) for later."; \
    ) | claude
    @echo "âœ… Spec draft created at assets/specs/{{name}}.md"

# Start Claude with automatic context injection
agent-start:
    @echo "ðŸš€ Initializing Agent with Context..."
    @just agent-context | claude

# ==============================================================================
# HUMAN INTERFACE (Interactive commands preserved)
# Commands with user prompts for manual operations
# ==============================================================================

# Interactive commit helper (for humans - uses select/read)
[group('git')]
commit:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "Interactive Conventional Commit"
    echo "================================"
    select TYPE in feat fix docs style refactor perf test build ci chore; do
        [ -n "$TYPE" ] && break
    done
    read -p "Enter scope (optional): " SCOPE
    SCOPE_STR=""
    if [ -n "$SCOPE" ]; then
        SCOPE_STR="($SCOPE)"
    fi
    read -p "Enter short description: " DESC
    read -p "Add detailed body? [y/N]: " -n 1 ADD_BODY
    echo
    BODY=""
    if [[ $ADD_BODY =~ ^[Yy]$ ]]; then
        echo "Enter body (Ctrl+D when done):"
        BODY=$(cat)
    fi
    read -p "Breaking change? [y/N]: " -n 1 BREAKING
    echo
    FOOTER=""
    if [[ $BREAKING =~ ^[Yy]$ ]]; then
        read -p "Describe breaking change: " BREAKING_DESC
        FOOTER="BREAKING CHANGE: $BREAKING_DESC"
    fi
    MSG="$TYPE$SCOPE_STR: $DESC"
    if [ -n "$BODY" ]; then
        MSG="$MSG\n\n$BODY"
    fi
    if [ -n "$FOOTER" ]; then
        MSG="$MSG\n\n$FOOTER"
    fi
    echo ""
    echo "Preview:"
    echo -e "$MSG"
    echo ""
    read -p "Commit? [Y/n]: " -n 1 CONFIRM
    echo
    if [[ ! $CONFIRM =~ ^[Nn]$ ]]; then
        git commit -m "$(echo -e "$MSG")"
        echo "Committed!"
    else
        echo "Cancelled"
        exit 1
    fi

# ==============================================================================
# SETUP & VALIDATION
# ==============================================================================

[group('setup')]
setup:
    @echo "ðŸš€ Setting up development environment..."
    @echo ""
    @echo "Step 1/3: Checking secrets configuration..."
    -@secretspec check --profile development 2>/dev/null || true
    @if ! secretspec check --profile development >/dev/null 2>&1; then \
        echo "âš ï¸  Secrets not configured."; \
        echo "   Checking if claude module needs to be disabled..."; \
        if grep -q "^    nixosModules.claude$" devenv.nix; then \
            echo "   Disabling claude module for initial setup..."; \
            sed -i '' 's/^    nixosModules.claude$/    # nixosModules.claude  # Disabled: configure secrets first/g' devenv.nix; \
            echo "   âœ… claude module disabled."; \
        else \
            echo "   âœ… claude module already disabled."; \
        fi; \
        echo ""; \
        echo "Step 2/3: Activating direnv (without claude module)..."; \
        direnv allow 2>/dev/null || true; \
        echo ""; \
        echo "Step 3/3: Environment ready (limited mode)."; \
        echo ""; \
        echo "ðŸ“ Next steps:"; \
        echo "   1. Configure secrets: https://secretspec.dev/concepts/providers/"; \
        echo "   2. Verify: just secrets-check"; \
        echo "   3. Re-run: just setup"; \
        echo ""; \
        echo "Run 'just' to see available commands."; \
    else \
        echo "âœ… Secrets OK!"; \
        echo ""; \
        echo "Step 2/3: Restoring claude module if needed..."; \
        if grep -q "^    # nixosModules.claude  # Disabled:" devenv.nix; then \
            sed -i '' 's/^    # nixosModules.claude  # Disabled:/    nixosModules.claude/g' devenv.nix; \
            echo "   âœ… claude module restored!"; \
        else \
            echo "   âœ… claude module already enabled."; \
        fi; \
        echo ""; \
        echo "Step 3/3: Activating direnv..."; \
        direnv allow; \
        echo ""; \
        echo "ðŸŽ‰ Environment fully ready!"; \
        echo ""; \
        echo "Run 'just' to see available commands."; \
    fi

[group('validate')]
validate: check-format check-commits lint test
    @echo "All validation checks passed!"

[group('validate')]
check-format:
    @echo "Checking code formatting..."
    @lefthook run pre-commit --all-files

[group('validate')]
lint:
    @echo "Linting files..."
    @lefthook run pre-commit

[group('validate')]
test:
    @echo "Running all tests in parallel (3 workers for stability)..."
    @uv run pytest packages/python/agent/src/agent/tests/ -n 3 --ignore=packages/python/agent/src/agent/tests/stress_tests -v

[group('validate')]
test-sequential:
    @echo "Running all tests sequentially (for debugging)..."
    @uv run pytest packages/python/agent/src/agent/tests/ -v --ignore=packages/python/agent/src/agent/tests/stress_tests

[group('validate')]
test-skills-parallel:
    @echo "Running skills tests in parallel..."
    @uv run pytest packages/python/agent/src/agent/tests/test_skills_full.py -n auto -v

[group('validate')]
test-stress:
    @echo "Running stress tests (slow)..."
    @uv run pytest packages/python/agent/src/agent/tests/stress_tests/ -v

# ==============================================================================
# MCP/SKILL TESTS
# ==============================================================================

[group('mcp')]
test-mcp:
    @echo "=== MCP Server Tests ==="
    @python -m compileall packages/python/agent/src/agent
    @echo "Syntax check: OK"
    @timeout 3 python -u packages/python/agent/src/agent/main.py 2>&1 || echo "Server startup: OK"
    @echo ""
    @echo "=== Skill Tests ==="
    @uv run pytest packages/python/agent/src/agent/tests/test_skills_full.py packages/python/agent/src/agent/tests/test_mcp_dependencies.py -v

[group('mcp')]
test-skills:
    @echo "=== Skill Architecture Tests ==="
    @uv run pytest packages/python/agent/src/agent/tests/test_skills_full.py -v

[group('mcp')]
test-skills-workflow:
    @echo "=== Skill Workflow Tests ==="
    @uv run pytest packages/python/agent/src/agent/tests/test_skills_full.py::TestSkillManagerOmniCLI -v

[group('mcp')]
test-git-security:
    @echo "=== Git Security Tests ==="
    @uv run pytest packages/python/agent/src/agent/tests/test_git_security.py -v

[group('mcp')]
test-mcp-all: test-mcp test-skills test-git-security
    @echo ""
    @echo "=== All MCP/Skill Tests Passed! ==="

# ==============================================================================
# CHANGELOG MANAGEMENT
# =============================================================================

[group('changelog')]
changelog-preview:
    @echo "Changelog Preview (since last tag)"
    @echo "===================================="
    @cog log
    @echo ""
    @echo "Commit breakdown:"
    @cog log | grep -oE "^(feat|fix|docs|style|refactor|perf|test|build|ci|chore)" | sort | uniq -c

[group('changelog')]
changelog-stats:
    @echo "Changelog Statistics"
    @echo "===================="
    @echo "Commits by type:"
    @cog log | grep -oE "^(feat|fix|docs|style|refactor|perf|test|build|ci|chore)" | sort | uniq -c | sort -rn
    @echo ""
    @echo "Commits by author:"
    @git log --format='%an' $(git describe --tags --abbrev=0 2>/dev/null || echo "HEAD")..HEAD | sort | uniq -c | sort -rn
    @echo ""
    @echo "Changes since last release:"
    @git diff --stat $(git describe --tags --abbrev=0 2>/dev/null || echo "HEAD")..HEAD

[group('validate')]
check-commits:
    @echo "Validating commit messages..."
    @cog check

[group('validate')]
check-commits-range from to:
    @cog check --from {{from}} --to {{to}}

[group('changelog')]
changelog:
    @echo "Generating changelog..."
    @cog changelog

[group('changelog')]
changelog-at version:
    @cog changelog --at {{version}}

[group('changelog')]
changelog-export version="latest":
    #!/usr/bin/env bash
    set -euo pipefail
    VERSION={{version}}
    if [ "$VERSION" = "latest" ]; then
        VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
    fi
    echo "Exporting changelog for $VERSION..."
    cog changelog --at "$VERSION" > "CHANGELOG_${VERSION}.md"
    echo "  Markdown: CHANGELOG_${VERSION}.md"
    cog log --format json > "CHANGELOG_${VERSION}.json"
    echo "  JSON: CHANGELOG_${VERSION}.json"
    cog changelog --at "$VERSION" | sed 's/\[//' | sed 's/\](.*)$//' > "CHANGELOG_${VERSION}.txt"
    echo "  Plain text: CHANGELOG_${VERSION}.txt"

# ==============================================================================
# VERSION MANAGEMENT & RELEASES
# ==============================================================================

[group('version')]
version:
    @echo "Current version: $(cat VERSION 2>/dev/null || git describe --tags --abbrev=0 2>/dev/null || echo 'No version found')"

[group('version')]
bump-auto: validate
    @echo "Auto-bumping version..."
    @cog bump --auto
    @just _sync-versions

[group('version')]
bump-patch: validate
    @echo "Bumping patch version..."
    @cog bump --patch
    @just _sync-versions

[group('version')]
bump-minor: validate
    @echo "Bumping minor version..."
    @cog bump --minor
    @just _sync-versions

[group('version')]
bump-major: validate
    @echo "Bumping major version..."
    @cog bump --major
    @just _sync-versions

# Sync versions across all packages from VERSION file
# Internal helper - called by bump-*
[private]
_sync-versions:
    #!/usr/bin/env bash
    set -euo pipefail
    NEW_VERSION=$(cat VERSION)
    echo "Syncing version $NEW_VERSION across all packages..."
    # Update agent pyproject.toml
    sed -i.bak "s/^version = \".*\"/version = \"$NEW_VERSION\"/" packages/python/agent/pyproject.toml && rm -f packages/python/agent/pyproject.toml.bak
    echo "  âœ“ Agent: packages/python/agent/pyproject.toml"
    # Update common pyproject.toml
    sed -i.bak "s/^version = \".*\"/version = \"$NEW_VERSION\"/" packages/python/common/pyproject.toml && rm -f packages/python/common/pyproject.toml.bak
    echo "  âœ“ Common: packages/python/common/pyproject.toml"
    # Note: Root pyproject.toml uses dynamic version (hatch-vcs), no sync needed
    echo ""
    echo "All packages updated to version $NEW_VERSION!"

[group('version')]
bump-dry:
    @echo "Previewing version bump (dry run)..."
    @cog bump --auto --dry-run

[group('version')]
bump-pre type="alpha":
    @echo "Creating pre-release ({{type}})..."
    @cog bump --pre {{type}}

# Set explicit version across all packages
# Usage: just bump-set 0.3.0
[group('version')]
bump-set version:
    #!/usr/bin/env bash
    set -euo pipefail
    NEW_VERSION="{{version}}"
    echo "Setting version to $NEW_VERSION across all packages..."
    # Update VERSION file
    echo "$NEW_VERSION" > VERSION
    # Sync to all pyproject.toml files
    just _sync-versions
    echo ""
    echo "Next steps:"
    echo "  1. Run: git add -A && git commit -m 'chore: bump version to $NEW_VERSION'"
    echo "  2. Run: git tag v$NEW_VERSION"
    echo "  3. Run: git push origin main v$NEW_VERSION"

[group('version')]
release-notes version="latest":
    #!/usr/bin/env bash
    set -euo pipefail
    VERSION={{version}}
    if [ "$VERSION" = "latest" ]; then
        VERSION=$(git describe --tags --abbrev=0)
    fi
    echo "# Release $VERSION"
    echo ""
    cog changelog --at "$VERSION" | sed -n "/^## \[v${VERSION#v}\]/,/^## \[v/p" | sed '$d'
    echo ""
    echo "---"
    echo "**Full Changelog**: https://github.com/tao3k/omni-dev-fusion/compare/$(git describe --tags --abbrev=0 $VERSION^ 2>/dev/null)...$VERSION"

[group('version')]
publish-release version="latest":
    #!/usr/bin/env bash
    set -euo pipefail
    VERSION={{version}}
    if [ "$VERSION" = "latest" ]; then
        VERSION=$(git describe --tags --abbrev=0)
    fi
    NOTES=$(mktemp)
    just release-notes "$VERSION" > "$NOTES"
    echo "Publishing release $VERSION to GitHub..."
    gh release create "$VERSION" --title "Release $VERSION" --notes-file "$NOTES" --verify-tag
    rm -f "$NOTES"
    echo "Published release $VERSION"

[group('version')]
release type="auto":
    @echo "Starting release workflow..."
    @just bump-{{type}}
    @just publish-release

# ==============================================================================
# GIT OPERATIONS
# ==============================================================================

[group('git')]
status:
    @echo "Repository Status"
    @echo "=================="
    @git status
    @echo ""
    @echo "Branch: $(git branch --show-current)"
    @echo "Last commit: $(git log -1 --oneline)"
    @echo "Last tag: $(git describe --tags --abbrev=0 2>/dev/null || echo 'No tags')"

[group('git')]
log n="10":
    @cog log --no-pager | head -n {{n}}

# ==============================================================================
# DEVELOPMENT HELPERS
# ==============================================================================

[group('dev')]
fmt:
    @echo "Formatting code..."
    @lefthook run pre-commit --all-files

[group('dev')]
fmt-py:
    @echo "Formatting Python with ruff..."
    @uvx ruff format packages/python/

[group('dev')]
clean:
    @echo "Cleaning generated files..."
    @rm -f CHANGELOG_*.md CHANGELOG_*.json CHANGELOG_*.txt RELEASE_NOTES_*.md
    @echo "Cleaned"

[group('dev')]
update:
    @echo "Updating dependencies..."
    @devenv update
    @echo "Updated"

[group('dev')]
info:
    @echo "Environment Information"
    @echo "======================"
    @echo "devenv version: $(devenv version)"
    @echo "nix version: $(nix --version)"
    @echo "just version: $(just --version)"
    @echo "cog version: $(cog --version 2>/dev/null || echo 'not found')"
    @echo "git version: $(git --version)"
    @echo ""
    @echo "Repository: $(git remote get-url origin 2>/dev/null || echo 'no remote')"
    @echo "Branch: $(git branch --show-current)"
    @echo "Version: $(cat VERSION 2>/dev/null || git describe --tags --abbrev=0 2>/dev/null || echo 'unknown')"

[group('dev')]
watch:
    @echo "Watching for changes..."
    @watchexec -e nix,md,sh -c "just check-format"

# ==============================================================================
# MCP SERVER COMMANDS
# ==============================================================================

[group('mcp')]
debug server="packages/python/agent/src/agent/main.py":
    @echo "Starting MCP Inspector..."
    @uv run mcp-inspector python {{server}}

[group('mcp')]
run server="packages/python/agent/src/agent/main.py":
    @echo "Running MCP server: {{server}}"
    @python {{server}}

# ==============================================================================
# SRE HEALTH CHECKS
# Outputs machine-parseable JSON for AI agents and CI/CD
# ==============================================================================

[group('sre')]
health: health-git health-nix health-secrets health-devenv
    @echo ""
    @echo "Health check complete!"

# Git repository health (JSON optional)
[group('sre')]
health-git:
    #!/usr/bin/env bash
    set -euo pipefail
    if [ "${JUST_JSON:-}" = "true" ]; then
        BRANCH=$(git branch --show-current)
        UNCOMMITTED=$(git status --porcelain | wc -l)
        LAST_COMMIT=$(git log -1 --oneline)
        BEHIND=0
        git fetch --quiet 2>/dev/null && BEHIND=$(git log HEAD..origin/$BRANCH 2>/dev/null | wc -l)
        jq -n --arg branch "$BRANCH" --argjson uncommitted "$UNCOMMITTED" --arg last_commit "$LAST_COMMIT" --argjson behind "$BEHIND" \
            '{component: "git", branch: $branch, uncommitted_files: $uncommitted, last_commit: $last_commit, commits_behind: $behind}'
    else
        echo "Git Health"
        echo "=========="
        echo "Branch: $(git branch --show-current)"
        echo "Status: $(git status --porcelain | wc -l) uncommitted files"
        echo "Last commit: $(git log -1 --oneline)"
    fi

# Nix/Devenv health
[group('sre')]
health-nix:
    #!/usr/bin/env bash
    set -euo pipefail
    if [ "${JUST_JSON:-}" = "true" ]; then
        NIX_VERSION=$(nix --version 2>/dev/null || echo "")
        jq -n --arg version "$NIX_VERSION" '{component: "nix", version: $version}'
    else
        echo "Nix Health"
        echo "=========="
        echo "Nix version: $(nix --version)"
    fi

# Devenv health
[group('sre')]
health-devenv:
    #!/usr/bin/env bash
    set -euo pipefail
    if [ "${JUST_JSON:-}" = "true" ]; then
        VERSION=$(devenv version 2>/dev/null || echo "")
        NIXPKGS=$(devenv nixpkgs-version 2>/dev/null || echo "")
        jq -n --arg version "$VERSION" --arg nixpkgs "$NIXPKGS" '{component: "devenv", version: $version, nixpkgs: $nixpkgs}'
    else
        echo "Devenv Health"
        echo "============="
        echo "Version: $(devenv version 2>/dev/null || echo 'not found')"
        echo "Nixpkgs: $(devenv nixpkgs-version 2>/dev/null || echo 'unknown')"
    fi

# Secrets health check (validates presence, never echoes values)
[group('sre')]
health-secrets:
    #!/usr/bin/env bash
    set -euo pipefail
    MISSING=""
    if [ -z "${MINIMAX_API_KEY:-}" ]; then
        MISSING="MINIMAX_API_KEY"
    fi
    if [ "${JUST_JSON:-}" = "true" ]; then
        if [ -z "$MISSING" ]; then
            jq -n '{component: "secrets", status: "pass", message: "All required secrets present"}'
        else
            jq -n --arg missing "$MISSING" \
                '{component: "secrets", status: "fail", message: "Missing secrets", missing_keys: [$missing]}'
            exit 1
        fi
    else
        echo "Secrets Health"
        echo "=============="
        echo "Provider: dotenv"
        if [ -z "$MISSING" ]; then
            echo "Status: OK"
        else
            echo "Status: MISSING - $MISSING"
        fi
    fi

# API keys health (presence check only)
[group('sre')]
health-api-keys:
    #!/usr/bin/env bash
    set -euo pipefail
    if [ "${JUST_JSON:-}" = "true" ]; then
        if [ -n "${MINIMAX_API_KEY:-}" ]; then
            jq -n '{component: "api_keys", minimax: "present"}'
        else
            jq -n '{component: "api_keys", minimax: "missing"}'
            exit 1
        fi
    else
        echo "API Keys Health"
        echo "==============="
        if [ -n "${MINIMAX_API_KEY:-}" ]; then
            echo "MINIMAX_API_KEY: Set"
        else
            echo "MINIMAX_API_KEY: Not set"
        fi
    fi

# Composite health report for agents
[group('sre')]
health-report:
    #!/usr/bin/env bash
    set -euo pipefail
    JUST_JSON=true just health-git
    JUST_JSON=true just health-devenv
    JUST_JSON=true just health-secrets

# ==============================================================================
# CI/CD COMMANDS
# ==============================================================================

[group('ci')]
ci: validate changelog-preview
    @echo "CI checks passed!"

[group('ci')]
pre-release: validate changelog-preview changelog-stats
    @echo ""
    @echo "Pre-release checks complete!"
    @echo ""
    @echo "Next steps:"
    @echo "  1. Review changelog preview"
    @echo "  2. Run: just bump-auto (or bump-patch/minor/major)"
    @echo "  3. Run: just publish-release"

# ==============================================================================
# SECRET MANAGEMENT (secretspec)
# ==============================================================================

[group('secrets')]
secrets-check:
    @echo "Checking secrets status..."
    @secretspec check --profile development

[group('secrets')]
secrets-info:
    @echo "Secret Management Info"
    @echo "======================"
    @echo "Provider: dotenv"
    @echo "Profile: development"
    @echo ""
    @echo "Configured secrets:"
    @secretspec check --profile development | grep -E "^\s+[A-Z]" || echo "  (none)"

[group('secrets')]
secrets-set-minimax:
    #!/usr/bin/env bash
    set -euo pipefail
    read -p "Enter MINIMAX_API_KEY: " -s API_KEY
    echo
    secretspec set MINIMAX_API_KEY --value "$API_KEY" --profile development
    echo "MINIMAX_API_KEY set"

[group('secrets')]
secrets-get-minimax:
    @secretspec get MINIMAX_API_KEY

# ==============================================================================
# DOCUMENTATION
# ==============================================================================

[group('docs')]
docs:
    @echo "Documentation Index"
    @echo "==================="
    @echo ""
    @echo "Available documentation:"
    @ls -1 *.md | sed 's/^/  - /'

[group('docs')]
examples:
    @echo "Commit Message Examples"
    @echo "======================="
    @echo ""
    @echo "feat: add new feature"
    @echo "feat(cli): add command"
    @echo "fix: correct bug"
    @echo "docs: update documentation"
    @echo "refactor: reorganize code"
    @echo "chore: maintenance tasks"
    @echo ""
    @echo "feat(api)!: breaking change"
    @echo "BREAKING CHANGE: description"

# ==============================================================================
# SPEC KIT (Spec-Driven Development)
# ==============================================================================

[group('spec')]
spec-list:
    @echo "Available Specs"
    @echo "================"
    @ls -1 assets/specs/*.md 2>/dev/null | sed 's|^assets/specs/||' | sed 's/\.md$//' | sed 's/^/  - /' || echo "  No specs found"

[group('spec')]
spec-template:
    @echo "Spec Template"
    @echo "============="
    @cat assets/specs/TEMPLATE.md

[group('spec')]
archive spec_path target_category="explanation":
    #!/usr/bin/env bash
    set -euo pipefail
    if [ -z "{{spec_path}}" ]; then
        echo "Usage: just archive <spec-path> [category]"
        echo "Example: just archive assets/specs/auth_module.md explanation"
        exit 1
    fi
    if [ ! -f "{{spec_path}}" ]; then
        echo "Error: Spec '{{spec_path}}' not found"
        exit 1
    fi
    echo "============================================"
    echo "ðŸ“¦ Archiving completed spec..."
    echo "============================================"
    echo "Spec: {{spec_path}}"
    echo "Category: {{target_category}}"
    echo ""
    echo "Ask the Agent to archive:"
    echo ""
    echo "  @omni-orchestrator archive_spec_to_doc spec_path=\"{{spec_path}}\" target_category=\"{{target_category}}\""
    echo ""
    echo "============================================"

# ==============================================================================
# ALIASES (using recipe definitions instead of variable assignments)
# ==============================================================================

check: validate
cl: changelog-preview
c: commit
s: status
ship: release

# Compatibility aliases for agent-* pattern
agent-ci: agent-validate
agent-test: test
agent-lint: lint
agent-format: fmt
